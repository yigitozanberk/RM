---
title: "week 4"
author: "Yigit Ozan Berk"
date: "8/1/2019"
output: html_document
---

# topics

- GLMs
- Logistic Regression
- Poisson Regression
- Hodgepodge
- Swirl Exc.
- Quiz
- Course Project

# GLMs

Generalized linear models (GLMs) were a great advance in statistical modeling. The original manuscript with the GLM framework was from Nelder and Wedderburn in 1972. in the Journal of the Royal Statistical Society. The McCullagh and Nelder book1 is the famous standard treatise on the subject.

Recall linear models. Linear models are the most useful applied statistical technique. However, they are not without their limitations. Additive response models don’t make much sense if the response is discrete, or strictly positive. Additive error models often don’t make sense, for example, if the outcome has to be positive. Transformations, such as taking a cube root of a count outcome, are often hard to interpret.In addition, there’s value in modeling the data on the scale that it was collected. Particularly interpretable transformations, natural logarithms in specific, aren’t applicable for negative or zero values.

The generalized linear model is family of models that includes linear models. By extending the family, it handles many of the issues with linear models, but at the expense of some complexity and loss of some of the mathematical tidiness. A GLM involves three components

An exponential family model for the response.
A systematic component via a linear predictor.
A link function that connects the means of the response to the linear predictor.
The three most famous cases of GLMs are: linear models, binomial and binary regression and Poisson regression. We’ll go through the GLM model specification and likelihood for all three. For linear models, we’ve developed them previously. The next two modules will be devoted to binomial and Poisson regression. We’ll only focus on the most popular and useful link functions.


## Linear models
* Linear models are the most useful applied statistical technique. However, they are not without their limitations.
  * Additive response models don't make much sense if the response is discrete, or stricly positive.
  * Additive error models often don't make sense, for example if the outcome has to be positive. 
  * Transformations are often hard to interpret. 
    * There's value in modeling the data on the scale that it was collected.
    * Particularly interpetable transformations, natural logarithms in specific,   aren't applicable for negative or zero values.



---
## Generalized linear models
* Introduced in a 1972 RSSB paper by Nelder and Wedderburn. 
* Involves three components
  * An *exponential family* model for the response.
  * A systematic component via a linear predictor.
  * A link function that connects the means of the response to the linear predictor.
  

---
## Example, linear models
* Assume that $Y_i \sim N(\mu_i, \sigma^2)$ (the Gaussian distribution is an exponential family distribution.)
* Define the linear predictor to be $\eta_i = \sum_{k=1}^p X_{ik} \beta_k$.
* The link function as $g$ so that $g(\mu) = \eta$.
  * For linear models $g(\mu) = \mu$ so that $\mu_i = \eta_i$
* This yields the same likelihood model as our additive error Gaussian linear model
$$
Y_i = \sum_{k=1}^p X_{ik} \beta_k + \epsilon_{i}
$$
where $\epsilon_i \stackrel{iid}{\sim} N(0, \sigma^2)$

---
## Example, logistic regression
* Assume that $Y_i \sim Bernoulli(\mu_i)$ so that $E[Y_i] = \mu_i$ where $0\leq \mu_i \leq 1$.
* Linear predictor $\eta_i = \sum_{k=1}^p X_{ik} \beta_k$
* Link function 
$g(\mu) = \eta = \log\left( \frac{\mu}{1 - \mu}\right)$
$g$ is the (natural) log odds, referred to as the **logit**.
* Note then we can invert the logit function as
$$
\mu_i = \frac{\exp(\eta_i)}{1 + \exp(\eta_i)} ~~~\mbox{and}~~~
1 - \mu_i = \frac{1}{1 + \exp(\eta_i)}
$$
Thus the likelihood is
$$
\prod_{i=1}^n \mu_i^{y_i} (1 - \mu_i)^{1-y_i}
= \exp\left(\sum_{i=1}^n y_i \eta_i \right)
\prod_{i=1}^n (1 + \eta_i)^{-1}
$$

---
## Example, Poisson regression
* Assume that $Y_i \sim Poisson(\mu_i)$ so that $E[Y_i] = \mu_i$ where $0\leq \mu_i$
* Linear predictor $\eta_i = \sum_{k=1}^p X_{ik} \beta_k$
* Link function 
$g(\mu) = \eta = \log(\mu)$
* Recall that $e^x$ is the inverse of $\log(x)$ so that 
$$
\mu_i = e^{\eta_i}
$$
Thus, the likelihood is
$$
\prod_{i=1}^n (y_i !)^{-1} \mu_i^{y_i}e^{-\mu_i}
\propto \exp\left(\sum_{i=1}^n y_i \eta_i - \sum_{i=1}^n \mu_i\right)
$$

---
## Some things to note
* In each case, the only way in which the likelihood depends on the data is through 
$$
\sum_{i=1}^n y_i \eta_i =
\sum_{i=1}^n y_i\sum_{k=1}^p X_{ik} \beta_k = 
\sum_{k=1}^p \beta_k\sum_{i=1}^n X_{ik} y_i
$$
Thus if we don't need the full data, only $\sum_{i=1}^n X_{ik} y_i$. This simplification is a consequence of chosing so-called 'canonical' link functions.
* (This has to be derived). All models achieve their maximum at the root of the so called normal equations
$$
0=\sum_{i=1}^n \frac{(Y_i - \mu_i)}{Var(Y_i)}W_i
$$
where $W_i$ are the derivative of the inverse of the link function.

---
## About variances
$$
0=\sum_{i=1}^n \frac{(Y_i - \mu_i)}{Var(Y_i)}W_i
$$
* For the linear model $Var(Y_i) = \sigma^2$ is constant.
* For Bernoulli case $Var(Y_i) = \mu_i (1 - \mu_i)$
* For the Poisson case $Var(Y_i) = \mu_i$. 
* In the latter cases, it is often relevant to have a more flexible variance model, even if it doesn't correspond to an actual likelihood
$$
0=\sum_{i=1}^n \frac{(Y_i - \mu_i)}{\phi \mu_i (1 - \mu_i ) } W_i ~~~\mbox{and}~~~
0=\sum_{i=1}^n \frac{(Y_i - \mu_i)}{\phi \mu_i} W_i
$$
* These are called 'quasi-likelihood' normal equations 

---
## Odds and ends
* The normal equations have to be solved iteratively. Resulting in 
$\hat \beta_k$ and, if included, $\hat \phi$.
* Predicted linear predictor responses can be obtained as $\hat \eta = \sum_{k=1}^p X_k \hat \beta_k$
* Predicted mean responses as $\hat \mu = g^{-1}(\hat \eta)$
* Coefficients are interpretted as 
$$
g(E[Y | X_k = x_k + 1, X_{\sim k} = x_{\sim k}]) - g(E[Y | X_k = x_k, X_{\sim k}=x_{\sim k}]) = \beta_k
$$
or the change in the link function of the expected response per unit change in $X_k$ holding other regressors constant.
* Variations on Newon/Raphson's algorithm are used to do it.
* Asymptotics are used for inference usually. 
* Many of the ideas from linear models can be brought over to GLMs.





# Logistic Regression - for binary outcomes

Binary GLMs come from trying to model outcomes that can take only two values. Some examples include: survival or not at the end of a study, winning versus losing of a team and success versus failure of a treatment or product. Often these outcomes are called Bernoulli outcomes, from the Bernoulli distribution named after the famous probabilist and mathematician.

If we happen to have several exchangeable binary outcomes for the same level of covariate values, then that is binomial data and we can aggregate the 0’s and 1’s into the count of 1’s. As an example, imagine if we sprayed insect pests with 4 different pesticides and counted whether they died or not. Then for each spray, we could summarize the data with the count of dead and total number that were sprayed and treat the data as binomial rather than Bernoulli.

- alive/dead
- win/loss
- success/failure
- etc

called binary, bernoulli or 0/1 outcomes

Two cases:
binary and binomial regression. (binomial is done by same logistic regression in the special case where the covariate is just constant)



## Key ideas

* Frequently we care about outcomes that have two values
  * Alive/dead
  * Win/loss
  * Success/Failure
  * etc
* Called binary, Bernoulli or 0/1 outcomes 
* Collection of exchangeable binary outcomes for the same covariate data are called binomial outcomes.

---

## Example Baltimore Ravens win/loss
### Ravens Data

```{r loadRavens,cache=TRUE}
load("./data/ravensData.rda")
head(ravensData)
```

---

## Linear regression

$$ RW_i = b_0 + b_1 RS_i + e_i $$

$RW_i$ - 1 if a Ravens win, 0 if not

$RS_i$ - Number of points Ravens scored

$b_0$ - probability of a Ravens win if they score 0 points

$b_1$ - increase in probability of a Ravens win for each additional point

$e_i$ - residual variation due 

---

## Linear regression in R

this is of course not the logical thing to do.

```{r linearReg, cache=TRUE}
lmRavens <- lm(ravensData$ravenWinNum ~ ravensData$ravenScore)
summary(lmRavens)$coef
```


---

## Odds

__Binary Outcome 0/1__

$$RW_i$$  

__Probability (0,1)__

$$\rm{Pr}(RW_i | RS_i, b_0, b_1 )$$


__Odds $(0,\infty)$__
$$\frac{\rm{Pr}(RW_i | RS_i, b_0, b_1 )}{1-\rm{Pr}(RW_i | RS_i, b_0, b_1)}$$ 

__Log odds $(-\infty,\infty)$__

$$\log\left(\frac{\rm{Pr}(RW_i | RS_i, b_0, b_1 )}{1-\rm{Pr}(RW_i | RS_i, b_0, b_1)}\right)$$  


---

## Linear vs. logistic regression

__Linear__

$$ RW_i = b_0 + b_1 RS_i + e_i $$

or

$$ E[RW_i | RS_i, b_0, b_1] = b_0 + b_1 RS_i$$

__Logistic__

$$ \rm{Pr}(RW_i | RS_i, b_0, b_1) = \frac{\exp(b_0 + b_1 RS_i)}{1 + \exp(b_0 + b_1 RS_i)}$$

or

$$ \log\left(\frac{\rm{Pr}(RW_i | RS_i, b_0, b_1 )}{1-\rm{Pr}(RW_i | RS_i, b_0, b_1)}\right) = b_0 + b_1 RS_i $$

---

## Interpreting Logistic Regression

$$ \log\left(\frac{\rm{Pr}(RW_i | RS_i, b_0, b_1 )}{1-\rm{Pr}(RW_i | RS_i, b_0, b_1)}\right) = b_0 + b_1 RS_i $$


$b_0$ - Log odds of a Ravens win if they score zero points

$b_1$ - Log odds ratio of win probability for each point scored (compared to zero points)

$\exp(b_1)$ - Odds ratio of win probability for each point scored (compared to zero points)

---
## Odds
- Imagine that you are playing a game where you flip a coin with success probability $p$.
- If it comes up heads, you win $X$. If it comes up tails, you lose $Y$.
- What should we set $X$ and $Y$ for the game to be fair?

    $$E[earnings]= X p - Y (1 - p) = 0$$
- Implies
    $$\frac{Y}{X} = \frac{p}{1 - p}$$    
- The odds can be said as "How much should you be willing to pay for a $p$ probability of winning a dollar?"
    - (If $p > 0.5$ you have to pay more if you lose than you get if you win.)
    - (If $p < 0.5$ you have to pay less if you lose than you get if you win.)

---
## Visualizing fitting logistic regression curves

```{r}
library(manipulate)
x <- seq(-10, 10, length = 1000)
manipulate(
    plot(x, exp(beta0 + beta1 * x) / (1 + exp(beta0 + beta1 * x)), 
         type = "l", lwd = 3, frame = FALSE),
    beta1 = slider(-2, 2, step = .1, initial = 2),
    beta0 = slider(-2, 2, step = .1, initial = 0)
    )
```

---

## Ravens logistic regression

```{r logReg, dependson = "loadRavens"}
logRegRavens <- glm(ravensData$ravenWinNum ~ ravensData$ravenScore,family="binomial")
summary(logRegRavens)
# if we had bounded count data, we would have to give it a sample size.
#by default it assumes the link function is the logit.

```
you want to look whether or not coefficient is close to 0 or not on the logit scale. on the exponentiated scale you want to check if it's close to 1.



---

## Ravens fitted values

```{r dependson = "logReg",fig.height=4,fig.width=4}
plot(ravensData$ravenScore,logRegRavens$fitted,pch=19,col="blue",xlab="Score",ylab="Prob Ravens Win")
#the fitted values are only showing a part of it. normally, the whole graph is same as the manipulate plot above.
```


---

## Odds ratios and confidence intervals

```{r dependson = "logReg",fig.height=4,fig.width=4}
exp(logRegRavens$coeff)
# 11% increase in the probability of winning whenever the ravens score.
exp(confint(logRegRavens))
```

our interval does contain 1. even though we know for sure that scoring points is what causes the Ravens to win the game, this coefficient turns out to not be significant.

---

## ANOVA for logistic regression

```{r dependson = "logReg",fig.height=4,fig.width=4}
anova(logRegRavens,test="Chisq")
```



---

## Interpreting Odds Ratios

* Not probabilities 
* Odds ratio of 1 = no difference in odds
* Log odds ratio of 0 = no difference in odds
* Odds ratio < 0.5 or > 2 commonly a "moderate effect"(or strong effect.)
* Relative risk $\frac{\rm{Pr}(RW_i | RS_i = 10)}{\rm{Pr}(RW_i | RS_i = 0)}$ often easier to interpret, harder to estimate
* For small probabilities RR $\approx$ OR but __they are not the same__!

[Wikipedia on Odds Ratio](http://en.wikipedia.org/wiki/Odds_ratio)


---

## Further resources

* [Wikipedia on Logistic Regression](http://en.wikipedia.org/wiki/Logistic_regression)
* [Logistic regression and glms in R](http://data.princeton.edu/R/glms.html)
* Brian Caffo's lecture notes on: [Simpson's paradox](http://ocw.jhsph.edu/courses/MethodsInBiostatisticsII/PDFs/lecture23.pdf), [Case-control studies](http://ocw.jhsph.edu/courses/MethodsInBiostatisticsII/PDFs/lecture24.pdf)
* [Open Intro Chapter on Logistic Regression](http://www.openintro.org/stat/down/oiStat2_08.pdf)







# count variables

Many data take the form of unbounded count data. For example, consider the number of calls to a call center or the number of flu cases in an area or the number of hits to a web site.

In some cases the counts are clearly bounded. However, modeling the counts as unbounded is often done when the upper limit is not known or very large relative to the number of events.

If the upper bound is known, the techniques we’re discussing can be used to model the proportion or rate. The starting point for most count analysis is the the Poisson distribution.

In the following lectures, we go over some of the basics of modeling count data.

## Key ideas

* Many data take the form of counts
  * Calls to a call center
  * Number of flu cases in an area
  * Number of cars that cross a bridge
* Data may also be in the form of rates
  * Percent of children passing a test
  * Percent of hits to a website from a country
* Linear regression with transformation is an option

---

## Poisson distribution
- The Poisson distribution is a useful model for counts and rates
- Here a rate is count per some monitoring time
- Some examples uses of the Poisson distribution
    - Modeling web traffic hits
    - Incidence rates
    - Approximating binomial probabilities with small $p$ and large $n$
    - Analyzing contigency table data

---
## The Poisson mass function
- $X \sim Poisson(t\lambda)$ if
$$
P(X = x) = \frac{(t\lambda)^x e^{-t\lambda}}{x!}
$$
For $x = 0, 1, \ldots$.
- The mean of the Poisson is $E[X] = t\lambda$, thus $E[X / t] = \lambda$
- The variance of the Poisson is $Var(X) = t\lambda$.
- The Poisson tends to a normal as $t\lambda$ gets large.

---

```{r simPois,fig.height=4,fig.width=8, cache=TRUE}
par(mfrow = c(1, 3))
plot(0 : 10, dpois(0 : 10, lambda = 2), type = "h", frame = FALSE)
plot(0 : 20, dpois(0 : 20, lambda = 10), type = "h", frame = FALSE)
plot(0 : 200, dpois(0 : 200, lambda = 100), type = "h", frame = FALSE) 
```

---

## Poisson distribution
### Sort of, showing that the mean and variance are equal
```{r}
x <- 0 : 10000; lambda = 3
mu <- sum(x * dpois(x, lambda = lambda))
sigmasq <- sum((x - mu)^2 * dpois(x, lambda = lambda))
c(mu, sigmasq)
```

---

## Example: Leek Group Website Traffic
* Consider the daily counts to Jeff Leek's web site

[http://biostat.jhsph.edu/~jleek/](http://biostat.jhsph.edu/~jleek/)

* Since the unit of time is always one day, set $t = 1$ and then
the Poisson mean is interpretted as web hits per day. (If we set $t = 24$, it would
be web hits per hour).

---

## Website data

```{r leekLoad,cache=TRUE}
#data is manually downloaded in the /data directory
load("./data/gaData.rda")
gaData$julian <- julian(gaData$date)
head(gaData)
#no data available
```

[http://skardhamar.github.com/rga/](http://skardhamar.github.com/rga/)


---

## Plot data

```{r, dependson="leekLoad",fig.height=4.5,fig.width=4.5}
plot(gaData$julian,gaData$visits,pch=19,col="darkgrey",xlab="Julian",ylab="Visits")
```


---

## Linear regression

$$ NH_i = b_0 + b_1 JD_i + e_i $$

$NH_i$ - number of hits to the website

$JD_i$ - day of the year (Julian day)

$b_0$ - number of hits on Julian day 0 (1970-01-01)

$b_1$ - increase in number of hits per unit day

$e_i$ - variation due to everything we didn't measure


---

## Linear regression line

```{r linReg}
plot(gaData$julian,gaData$visits,pch=19,col="darkgrey",xlab="Julian",ylab="Visits")
lm1 <- lm(gaData$visits ~ gaData$julian)
abline(lm1,col="red",lwd=3)
```
---

## Aside, taking the log of the outcome
- Taking the natural log of the outcome has a specific interpretation.
- Consider the model

$$ \log(NH_i) = b_0 + b_1 JD_i + e_i $$

$NH_i$ - number of hits to the website

$JD_i$ - day of the year (Julian day)

$b_0$ - log number of hits on Julian day 0 (1970-01-01)

$b_1$ - increase in log number of hits per unit day

$e_i$ - variation due to everything we didn't measure

---
## Exponentiating coefficients
- $e^{E[\log(Y)]}$ geometric mean of $Y$. 
    - With no covariates, this is estimated by $e^{\frac{1}{n}\sum_{i=1}^n \log(y_i)} = (\prod_{i=1}^n y_i)^{1/n}$
- When you take the natural log of outcomes and fit a regression model, your exponentiated coefficients
estimate things about geometric means.
- $e^{\beta_0}$ estimated geometric mean hits on day 0
- $e^{\beta_1}$ estimated relative increase or decrease in geometric mean hits per day
- There's a problem with logs with you have zero counts, adding a constant works


```{r}
round(exp(coef(lm(I(log(gaData$visits + 1)) ~ gaData$julian))), 5)
```



---

## Linear vs. Poisson regression

__Linear__

$$ NH_i = b_0 + b_1 JD_i + e_i $$

or

$$ E[NH_i | JD_i, b_0, b_1] = b_0 + b_1 JD_i$$

__Poisson/log-linear__

$$ \log\left(E[NH_i | JD_i, b_0, b_1]\right) = b_0 + b_1 JD_i $$

or

$$ E[NH_i | JD_i, b_0, b_1] = \exp\left(b_0 + b_1 JD_i\right) $$


---

## Multiplicative differences

<br><br>
$$ E[NH_i | JD_i, b_0, b_1] = \exp\left(b_0 + b_1 JD_i\right) $$

<br><br>

$$ E[NH_i | JD_i, b_0, b_1] = \exp\left(b_0 \right)\exp\left(b_1 JD_i\right) $$

<br><br>

If $JD_i$ is increased by one unit, $E[NH_i | JD_i, b_0, b_1]$ is multiplied by $\exp\left(b_1\right)$

---

## Poisson regression in R

```{r poisReg, dependson="linReg",fig.height=4.5,fig.width=4.5, cache=TRUE}
plot(gaData$julian,gaData$visits,pch=19,col="darkgrey",xlab="Julian",ylab="Visits")
glm1 <- glm(gaData$visits ~ gaData$julian,family="poisson")
abline(lm1,col="red",lwd=3); lines(gaData$julian,glm1$fitted,col="blue",lwd=3)
```


---

## Mean-variance relationship?

```{r, dependson="poisReg",fig.height=4.5,fig.width=4.5}
plot(glm1$fitted,glm1$residuals,pch=19,col="grey",ylab="Residuals",xlab="Fitted")
#the variance has to go up as the mean goes up. this is a problem.
```

---

## Model agnostic standard errors 

```{r agnostic}
#solution - quasi possion variables
#this model looks at variance as a constant multiple of the mean, rather than being equal to the mean
#but this is not the case here. it looks like we have this issue when there's larger variance for lower fitted values
library(sandwich) 
#sandwich variance estimator. invented in John's Hopkins
confint.agnostic <- function (object, parm, level = 0.95, ...)
{
    cf <- coef(object); pnames <- names(cf)
    if (missing(parm))
        parm <- pnames
    else if (is.numeric(parm))
        parm <- pnames[parm]
    a <- (1 - level)/2; a <- c(a, 1 - a)
    pct <- stats:::format.perc(a, 3)
    fac <- qnorm(a)
    ci <- array(NA, dim = c(length(parm), 2L), dimnames = list(parm,
                                                               pct))
    ses <- sqrt(diag(sandwich::vcovHC(object)))[parm]
    ci[] <- cf[parm] + ses %o% fac
    ci
}
```
[http://stackoverflow.com/questions/3817182/vcovhc-and-confidence-interval](http://stackoverflow.com/questions/3817182/vcovhc-and-confidence-interval)

very important applied topic. 
to understand whether your variance models hold.
---

## Estimating confidence intervals

```{r}
confint(glm1)
#if we don't do anything
confint.agnostic(glm1)
#here it doesn't make that big of a difference, but still the second one is the correct model here.
```


---

## Rates 


<br><br>


$$ E[NHSS_i | JD_i, b_0, b_1]/NH_i = \exp\left(b_0 + b_1 JD_i\right) $$
we want to actually interpret not the expected value of the outcome, but the expected value of the outcome divided by this relative term. in this case, the expected value of hits originating from the Simply Statistics page, divided by the total number of hits of JT Leek's general website.

<br><br>

$$ \log\left(E[NHSS_i | JD_i, b_0, b_1]\right) - \log(NH_i)  =  b_0 + b_1 JD_i $$

<br><br>

$$ \log\left(E[NHSS_i | JD_i, b_0, b_1]\right) = \log(NH_i) + b_0 + b_1 JD_i $$
it turns out this is all you have to do to add a regular proportion into a poission GLM. 

---

## Fitting rates in R 

```{r ratesFit,dependson="agnostic", cache=TRUE,fig.height=4,fig.width=4}
#adding the log(NHi) term to the model
glm2 <- glm(gaData$simplystats ~ julian(gaData$date),offset=log(visits+1),
            family="poisson",data=gaData)
#visits + 1 because we can't take the log if 0.
#offset = log(visits + 1) this is how you add an offset term to the model. 
#alternatively, at the right side of the tilda you can use ~O(visits+1)
plot(julian(gaData$date),glm2$fitted,col="blue",pch=19,xlab="Date",ylab="Fitted Counts")
points(julian(gaData$date),glm1$fitted,col="red",pch=19)
```

blue points are adjusted for the red points.


---

## Fitting rates in R 

```{r,dependson="ratesFit",fig.height=4,fig.width=4}
glm2 <- glm(gaData$simplystats ~ julian(gaData$date),offset=log(visits+1),
            family="poisson",data=gaData)
plot(julian(gaData$date),gaData$simplystats/(gaData$visits+1),col="grey",xlab="Date",
     ylab="Fitted Rates",pch=19)
lines(julian(gaData$date),glm2$fitted/(gaData$visits+1),col="blue",lwd=3)
```
blue line is the fitted model. a lot of 0s early on, takes off after a while.
zero inflation is a serious problem here, also because it has a temporal component

---

## More information

* [Log-linear models and multiway tables](http://ww2.coastal.edu/kingw/statistics/R-tutorials/loglin.html)
* [Wikipedia on Poisson regression](http://en.wikipedia.org/wiki/Poisson_regression), [Wikipedia on overdispersion](http://en.wikipedia.org/wiki/Overdispersion)
* [Regression models for count data in R](http://cran.r-project.org/web/packages/pscl/vignettes/countreg.pdf)
* [pscl package](http://cran.r-project.org/web/packages/pscl/index.html) - the function _zeroinfl_ fits zero inflated models. 








Bonus
This lecture is a bit of an mishmash of interesting things that one can accomplish with linear models.


## How to fit functions using linear models
* Consider a model $Y_i = f(X_i) + \epsilon$. 
* How can we fit such a model using linear models (called scatterplot smoothing)
* Consider the model 
  $$
  Y_i = \beta_0 + \beta_1 X_i + \sum_{k=1}^d (x_i - \xi_k)_+ \gamma_k + \epsilon_{i}
  $$
where $(a)_+ = a$ if $a > 0$ and $0$ otherwise and $\xi_1 \leq ... \leq \xi_d$ are known knot points.
* Prove to yourelf that the mean function
$$
\beta_0 + \beta_1 X_i + \sum_{k=1}^d (x_i - \xi_k)_+ \gamma_k
$$
is continuous at the knot points.
---
## Simulated example
```{r, fig.height=4, fig.width=4}
n <- 500; x <- seq(0, 4 * pi, length = n); y <- sin(x) + rnorm(n, sd = .3)
knots <- seq(0, 8 * pi, length = 20); 
splineTerms <- sapply(knots, function(knot) (x > knot) * (x - knot))
xMat <- cbind(1, x, splineTerms)
yhat <- predict(lm(y ~ xMat - 1))
plot(x, y, frame = FALSE, pch = 21, bg = "lightblue", cex = 2)
lines(x, yhat, col = "red", lwd = 2)
```
---
## Adding squared terms
* Adding squared terms makes it continuously differentiable at the knot points.
* Adding cubic terms makes it twice continuously differentiable at the knot points; etcetera.
$$
  Y_i = \beta_0 + \beta_1 X_i + \beta_2 X_i^2 + \sum_{k=1}^d (x_i - \xi_k)_+^2 \gamma_k + \epsilon_{i}
$$

---
```{r, fig.height=4, fig.width=4}  
splineTerms <- sapply(knots, function(knot) (x > knot) * (x - knot)^2)
xMat <- cbind(1, x, x^2, splineTerms)
yhat <- predict(lm(y ~ xMat - 1))
plot(x, y, frame = FALSE, pch = 21, bg = "lightblue", cex = 2)
lines(x, yhat, col = "red", lwd = 2)
```

---
## Notes
* The collection of regressors is called a basis.
  * People have spent **a lot** of time thinking about bases for this kind of problem. So, consider this as just a teaser.
* Single knot point terms can fit hockey stick like processes.
* These bases can be used in GLMs as well.
* An issue with these approaches is the large number of parameters introduced. 
  * Requires some method of so called regularization.

---
## Harmonics using linear models
```{r}
##Chord finder, playing the white keys on a piano from octave c4 - c5
notes4 <- c(261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25)
t <- seq(0, 2, by = .001); n <- length(t)
c4 <- sin(2 * pi * notes4[1] * t); e4 <- sin(2 * pi * notes4[3] * t); 
g4 <- sin(2 * pi * notes4[5] * t)
chord <- c4 + e4 + g4 + rnorm(n, 0, 0.3)
x <- sapply(notes4, function(freq) sin(2 * pi * freq * t))
fit <- lm(chord ~ x - 1)
```

---
```{r, fig.height=5,fig.width=5, echo=FALSE}
plot(c(0, 9), c(0, 1.5), xlab = "Note", ylab = "Coef^2", axes = FALSE, frame = TRUE, type = "n")
axis(2)
axis(1, at = 1 : 8, labels = c("c4", "d4", "e4", "f4", "g4", "a4", "b4", "c5"))
for (i in 1 : 8) abline(v = i, lwd = 3, col = grey(.8))
lines(c(0, 1 : 8, 9), c(0, coef(fit)^2, 0), type = "l", lwd = 3, col = "red")
```

---
```{r, fig.height=5, fig.wdith=5}
##(How you would really do it)
a <- fft(chord); plot(Re(a)^2, type = "l")
```













------------------------------------------
# Chapter 8 exercises from caffo book

```{r}
library(datasets)
data(Seatbelts)
seatbelts <- as.data.frame(Seatbelts)
#because in the original datasets no. of people killed for 0 kms driven is not very meaningful(because the range of kms variables is very big, and no. of people killed for 0 pounds of petrol price is not very meaningful because petrol price is created with a retail index, we change and scale them a little to make sense)
#also, kms is >0. centering it allows a better understanding
library(dplyr)
seatbelts = mutate(seatbelts,
                   #standardized Petrol Price
                   pp = (PetrolPrice - mean(PetrolPrice))/sd(PetrolPrice),
                   #megameters
                   mm = kms/1000,
                   mmc = mm - mean(mm))
head(seatbelts)
```

```{r}
fit <- lm(DriversKilled ~ pp + mmc, seatbelts)
summary(fit)
```
we're expecting 7 fewer deaths in 1 std. deviation change in petrol price, holding the kms constant.

we're expecting around 2 fewer deaths for every additional 1000 kms drivven, holding the pp constant.

question2
```{r}
#we just want to predict
fit2 <- lm(DriversKilled ~ kms + PetrolPrice, data = seatbelts)
summary(fit2)$coef
predict(fit2, newdata = data.frame(kms = mean(seatbelts$kms), PetrolPrice = mean(seatbelts$PetrolPrice)), interval = "prediction")
```


question3

```{r}
ey <- resid(lm(DriversKilled ~ kms, data = seatbelts))
ex <- resid(lm(PetrolPrice ~ kms, data = seatbelts))
summary(lm(ey ~ ex - 1))$coef
```

```{r}
summary(fit2)$coef
```

identical coefficients of petrol price variable

question4

```{r}
edk <- resid(lm(DriversKilled ~ PetrolPrice, data = seatbelts))
ekm <- resid(lm(kms ~ PetrolPrice, data = seatbelts))
summary(lm(edk ~ ekm - 1))$coef
summary(fit2)$coef
```

Binary Problems

```{r}
library(datasets)
library(dplyr)
data(Seatbelts)
seatbelts = as.data.frame(Seatbelts)
seatbelts = mutate(seatbelts,
                   dkb = 1 * (DriversKilled >119),
                   pp = (PetrolPrice - mean(PetrolPrice))/sd(PetrolPrice),
                   mm = kms/1000,
                   mmc = mm- mean(mm))
table(seatbelts$dkb)

```


```{r}
fit = glm(dkb ~ pp + mmc + law, family = "binomial", data = seatbelts)
summary(fit)$coef
round(summary(fit)$coef, 3)
```

logit scale odds of having > 119 drivers killed that month is 0.003 lower for every 1000 kms driven.

```{r}
#law coefficient
exp(-0.615522450)
```

There was a 54% more deaths before the law was enacted.

conversely
```{r}
1 - exp(-0.615522450)
```

There was a 45% decrease in deaths after the law was enacted. Holding the other variables constant.

```{r}
exp(-0.002938343)
```

.3% decrease in the odds of greater than 119 drivers killed that month for every additional 1000 kms driven that month

```{r}
fit2 <- glm(cbind(DriversKilled, drivers - DriversKilled) ~ pp + mmc + law, family = binomial, data = seatbelts)
summary(fit2)
```

anova for model comparison

```{r}
fit_1 = glm(dkb ~ law, family = "binomial", data = seatbelts)
fit_2 = glm(dkb ~ law + pp, family = binomial, data = seatbelts)
fit_3 = glm(dkb ~ law + pp + mmc, family = binomial, data = seatbelts)
anova(fit_1, fit_2, fit_3)
```



Examples and tricks section 

question 1

```{r}
library(datasets)
data(Seatbelts)
seatbelts <- as.data.frame(Seatbelts)
#because in the original datasets no. of people killed for 0 kms driven is not very meaningful(because the range of kms variables is very big, and no. of people killed for 0 pounds of petrol price is not very meaningful because petrol price is created with a retail index, we change and scale them a little to make sense)
#also, kms is >0. centering it allows a better understanding
library(dplyr)
seatbelts = mutate(seatbelts,
                   #standardized Petrol Price
                   pp = (PetrolPrice - mean(PetrolPrice))/sd(PetrolPrice),
                   #megameters
                   mm = kms/1000,
                   mmc = mm - mean(mm))
head(seatbelts)
```

```{r}
fit = lm(DriversKilled ~ mmc + pp, data = seatbelts)
summary(fit)
```

```{r}
fit2 = lm(I(log(DriversKilled)) ~ mmc + pp, data = seatbelts)
summary(fit2)
```

question 3

```{r}
seatbelts$lawFactor <- NULL
for(i in 1:nrow(seatbelts)) {
  if(seatbelts$law[i] == 0){
    seatbelts$lawFactor[i] <- "No" 
  } else {
    seatbelts$lawFactor[i] <- "Yes"
  }
}

seatbelts$lawFactor <- relevel(as.factor(seatbelts$lawFactor), "Yes")

fit3 <- lm(DriversKilled ~ mmc + pp + lawFactor, data = seatbelts)
summary(fit3)
```


question 4

```{r}
seatbelts = mutate(seatbelts,
                   #standardized Petrol Price
                   pp = (PetrolPrice - mean(PetrolPrice))/sd(PetrolPrice),
                   ppf = as.factor((pp <= -1.5) + (pp <= 0) + (pp <= 1.5) + (pp < Inf)),
                   #megameters
                   mm = kms/1000,
                   mmc = mm - mean(mm))
head(seatbelts)
summary(lm(DriversKilled ~ ppf + mmc+ law, data = seatbelts))
```

